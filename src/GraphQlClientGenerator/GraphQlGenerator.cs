using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Newtonsoft.Json.Serialization;

namespace GraphQlClientGenerator
{
    public class GraphQlGenerator
    {
        private const string PreprocessorDirectiveDisableNewtonsoftJson = "GRAPHQL_GENERATOR_DISABLE_NEWTONSOFT_JSON";
        private const string AutoGeneratedPrefix = "// <auto-generated> This file has been auto generated. </auto-generated>";

        internal const string RequiredNamespaces =
            @"using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
#if!" + PreprocessorDirectiveDisableNewtonsoftJson + @"
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
#endif
";

        private delegate void WriteDataClassPropertyBodyDelegate(ScalarFieldTypeDescription netType, string backingFieldName);

        private static readonly HttpClient HttpClient =
            new HttpClient
            {
                DefaultRequestHeaders = { UserAgent = { ProductInfoHeaderValue.Parse("GraphQlGenerator/" + typeof(GraphQlGenerator).GetTypeInfo().Assembly.GetName().Version) } }
            };

        internal static readonly JsonSerializerSettings SerializerSettings =
            new JsonSerializerSettings
            {
                ContractResolver = new CamelCasePropertyNamesContractResolver(),
                Converters = { new StringEnumConverter() }
            };

        private readonly GraphQlGeneratorConfiguration _configuration;

        public GraphQlGenerator(GraphQlGeneratorConfiguration configuration = null)
        {
            _configuration = configuration ?? new GraphQlGeneratorConfiguration();
        }

        public static async Task<GraphQlSchema> RetrieveSchema(string url, string authorization = null)
        {
            using var request =
                new HttpRequestMessage(HttpMethod.Post, url)
                {
                    Content = new StringContent(JsonConvert.SerializeObject(new { query = IntrospectionQuery.Text }), Encoding.UTF8, "application/json")
                };

            if (!String.IsNullOrWhiteSpace(authorization))
                request.Headers.Authorization = AuthenticationHeaderValue.Parse(authorization);
            
            using var response = await HttpClient.SendAsync(request);

            var content =
                response.Content == null
                    ? "(no content)"
                    : await response.Content.ReadAsStringAsync();

            if (!response.IsSuccessStatusCode)
                throw new InvalidOperationException($"Status code: {(int)response.StatusCode} ({response.StatusCode}){Environment.NewLine}content:{Environment.NewLine}{content}");

            return DeserializeGraphQlSchema(content);
        }

        public static GraphQlSchema DeserializeGraphQlSchema(string content)
        {
            try
            {
                var result = JsonConvert.DeserializeObject<GraphQlResult>(content, SerializerSettings);
                if (result.Data?.Schema == null)
                    throw new ArgumentException("not a GraphQL schema", nameof(content));

                return result.Data.Schema;
            }
            catch (JsonReaderException exception)
            {
                throw new ArgumentException("not a GraphQL schema", nameof(content), exception);
            }
        }

        public string GenerateFullClientCSharpFile(GraphQlSchema schema, string @namespace)
        {
            var builder = new StringBuilder();
            builder.AppendLine(AutoGeneratedPrefix);
            builder.AppendLine();
            builder.AppendLine(RequiredNamespaces);
            builder.Append("namespace ");
            builder.AppendLine(@namespace);
            builder.AppendLine("{");

            var memberBuilder = new StringBuilder();
            GenerateQueryBuilder(schema, memberBuilder);

            memberBuilder.AppendLine();
            memberBuilder.AppendLine();

            GenerateDataClasses(schema, memberBuilder);

            var indentedLines =
                memberBuilder
                    .ToString()
                    .Split(new[] { Environment.NewLine }, StringSplitOptions.None)
                    .Select(l => "    " + l);

            foreach (var line in indentedLines)
                builder.AppendLine(line);

            builder.AppendLine("}");

            return builder.ToString();
        }

        private static bool IsComplexType(GraphQlTypeKind graphQlTypeKind) =>
            graphQlTypeKind == GraphQlTypeKind.Object || graphQlTypeKind == GraphQlTypeKind.Interface || graphQlTypeKind == GraphQlTypeKind.Union;

        private void GenerateSharedTypes(GraphQlSchema schema, TextWriter writer)
        {
            writer.WriteLine("#region shared types");
            GenerateEnums(schema, writer);
            writer.WriteLine("#endregion");
            writer.WriteLine();
        }

        public void GenerateQueryBuilder(GraphQlSchema schema, StringBuilder builder)
        {
            using var writer = new StringWriter(builder);
            GenerateQueryBuilder(schema, writer);
        }

        public void GenerateQueryBuilder(GraphQlSchema schema, TextWriter writer)
        {
            using (var reader = new StreamReader(typeof(GraphQlGenerator).GetTypeInfo().Assembly.GetManifestResourceStream("GraphQlClientGenerator.BaseClasses.cs")))
                writer.WriteLine(reader.ReadToEnd());

            GenerateSharedTypes(schema, writer);

            if (_configuration.CSharpVersion == CSharpVersion.NewestWithNullableReferences)
                writer.WriteLine("#nullable enable");

            writer.WriteLine("#region directives");
            GenerateDirectives(schema, writer);
            writer.WriteLine("#endregion");

            writer.WriteLine();

            writer.WriteLine("#region builder classes");

            var complexTypes = schema.Types.Where(t => IsComplexType(t.Kind) && !t.Name.StartsWith("__")).ToArray();
            var complexTypeDictionary = complexTypes.ToDictionary(t => t.Name);
            for (var i = 0; i < complexTypes.Length; i++)
            {
                var type = complexTypes[i];
                GenerateTypeQueryBuilder(type, complexTypeDictionary, schema, writer);

                if (i < complexTypes.Length - 1)
                    writer.WriteLine();
            }

            writer.WriteLine("#endregion");

            if (_configuration.CSharpVersion == CSharpVersion.NewestWithNullableReferences)
                writer.WriteLine("#nullable restore");
        }

        private static void FindAllReferencedObjectTypes(GraphQlSchema schema, GraphQlType type, ISet<string> objectTypes)
        {
            foreach (var member in (IEnumerable<IGraphQlMember>)type.InputFields ?? type.Fields)
            {
                var unwrappedType = member.Type.UnwrapIfNonNull();
                GraphQlType memberType;
                switch (unwrappedType.Kind)
                {
                    case GraphQlTypeKind.Object:
                        objectTypes.Add(unwrappedType.Name);
                        memberType = schema.Types.Single(t => t.Name == unwrappedType.Name);
                        FindAllReferencedObjectTypes(schema, memberType, objectTypes);
                        break;

                    case GraphQlTypeKind.List:
                        var itemType = unwrappedType.OfType.UnwrapIfNonNull();
                        if (IsComplexType(itemType.Kind))
                        {
                            memberType = schema.Types.Single(t => t.Name == itemType.Name);
                            FindAllReferencedObjectTypes(schema, memberType, objectTypes);
                        }

                        break;
                }
            }
        }

        public void GenerateDataClasses(GraphQlSchema schema, StringBuilder builder)
        {
            using var writer = new StringWriter(builder);
            GenerateDataClasses(schema, writer);
        }

        public void GenerateDataClasses(GraphQlSchema schema, TextWriter writer)
        {
            var inputTypes = schema.Types.Where(t => t.Kind == GraphQlTypeKind.InputObject && !t.Name.StartsWith("__")).ToArray();
            var hasInputType = inputTypes.Any();
            var referencedObjectTypes = new HashSet<string>();

            if (hasInputType)
                writer.WriteLine();

            if (_configuration.CSharpVersion == CSharpVersion.NewestWithNullableReferences)
                writer.WriteLine("#nullable enable");

            if (hasInputType)
            {
                writer.WriteLine("#region input classes");

                for (var i = 0; i < inputTypes.Length; i++)
                {
                    var type = inputTypes[i];
                    FindAllReferencedObjectTypes(schema, type, referencedObjectTypes);
                    GenerateDataClass(NamingHelper.ToPascalCase(type.Name), type.Description, "IGraphQlInputObject", writer, () => GenerateInputDataClassBody(type, type.InputFields.Cast<IGraphQlMember>().ToArray(), writer));

                    writer.WriteLine();

                    if (i < inputTypes.Length - 1)
                        writer.WriteLine();
                }

                writer.WriteLine("#endregion");
            }

            var complexTypes = schema.Types.Where(t => IsComplexType(t.Kind) && !t.Name.StartsWith("__")).ToArray();
            if (complexTypes.Any())
            {
                if (hasInputType)
                    writer.WriteLine();

                var complexTypeDictionary = complexTypes.ToDictionary(t => t.Name);

                writer.WriteLine("#region data classes");

                for (var i = 0; i < complexTypes.Length; i++)
                {
                    var type = complexTypes[i];
                    var hasInputReference = referencedObjectTypes.Contains(type.Name);
                    var fieldsToGenerate = GetFieldsToGenerate(type, complexTypeDictionary);
                    var isInterface = type.Kind == GraphQlTypeKind.Interface;
                    var csharpTypeName = type.Name;
                    if (!UseCustomClassNameIfDefined(ref csharpTypeName))
                        csharpTypeName = NamingHelper.ToPascalCase(csharpTypeName);

                    void GenerateBody(bool isInterfaceMember)
                    {
                        if (hasInputReference)
                            GenerateInputDataClassBody(type, fieldsToGenerate, writer);
                        else if (fieldsToGenerate != null)
                        {
                            var generateBackingFields = _configuration.PropertyGeneration == PropertyGenerationOption.BackingField && !isInterfaceMember;
                            if (generateBackingFields)
                            {
                                foreach (var field in fieldsToGenerate)
                                {
                                    writer.Write("    private ");
                                    writer.Write(GetDataPropertyType(type, field).NetTypeName);
                                    writer.Write(" ");
                                    writer.Write(GetBackingFieldName(field.Name));
                                    writer.WriteLine(";");
                                }

                                writer.WriteLine();
                            }

                            foreach (var field in fieldsToGenerate)
                                GenerateDataProperty(
                                    type,
                                    field,
                                    isInterfaceMember,
                                    field.IsDeprecated,
                                    field.DeprecationReason,
                                    true,
                                    (_, backingFieldName) =>
                                        writer.Write(generateBackingFields ? _configuration.PropertyAccessorBodyWriter(backingFieldName, GetDataPropertyType(type, field)) : " { get; set; }"),
                                    writer);
                        }
                    }

                    var interfacesToImplement = new List<string>();
                    if (isInterface)
                    {
                        interfacesToImplement.Add(GenerateInterface("I" + csharpTypeName, type.Description, writer, () => GenerateBody(true)));
                        writer.WriteLine();
                        writer.WriteLine();
                    }
                    else if (type.Interfaces?.Count > 0)
                    {
                        var fieldNames = new HashSet<string>(fieldsToGenerate.Select(f => f.Name));

                        foreach (var @interface in type.Interfaces)
                        {
                            interfacesToImplement.Add("I" + @interface.Name + _configuration.ClassPostfix);

                            foreach (var interfaceField in complexTypeDictionary[@interface.Name].Fields.Where(FilterDeprecatedFields))
                                if (fieldNames.Add(interfaceField.Name))
                                    fieldsToGenerate.Add(interfaceField);
                        }
                    }

                    if (hasInputReference)
                        interfacesToImplement.Add("IGraphQlInputObject");

                    GenerateDataClass(csharpTypeName, type.Description, String.Join(", ", interfacesToImplement), writer, () => GenerateBody(false));

                    writer.WriteLine();

                    if (i < complexTypes.Length - 1)
                        writer.WriteLine();
                }

                writer.WriteLine("#endregion");
            }

            if (_configuration.CSharpVersion == CSharpVersion.NewestWithNullableReferences)
                writer.WriteLine("#nullable restore");
        }

        private static string GetBackingFieldName(string graphQlFieldName) => "_" + NamingHelper.LowerFirst(NamingHelper.ToPascalCase(graphQlFieldName));

        private void GenerateInputDataClassBody(GraphQlType type, IEnumerable<IGraphQlMember> members, TextWriter writer)
        {
            var fieldNameMembers = new Dictionary<string, IGraphQlMember>();
            foreach (var member in members)
            {
                var fieldName = GetBackingFieldName(member.Name);
                fieldNameMembers.Add(fieldName, member);

                writer.Write("    private InputPropertyInfo ");
                writer.Write(fieldName);
                writer.WriteLine(";");
            }

            writer.WriteLine();

            var useCompatibleSyntax = _configuration.CSharpVersion == CSharpVersion.Compatible;

            foreach (var kvp in fieldNameMembers)
                GenerateDataProperty(
                    type,
                    kvp.Value,
                    false,
                    false,
                    null,
                    true,
                    (t, _) =>
                    {
                        writer.WriteLine();
                        writer.WriteLine("    {");
                        writer.Write("        get");
                        writer.Write(useCompatibleSyntax ? " { return " : " => ");
                        writer.Write("(");
                        writer.Write(t.NetTypeName);
                        writer.Write(")");
                        writer.Write(kvp.Key);
                        writer.Write(".Value;");

                        if (useCompatibleSyntax)
                            writer.Write(" }");

                        writer.WriteLine();

                        writer.Write("        set");
                        writer.Write(useCompatibleSyntax ? " { " : " => ");
                        writer.Write(kvp.Key);
                        writer.Write(" = new InputPropertyInfo { Name = \"");
                        writer.Write(kvp.Value.Name);
                        writer.Write("\", Value = value");

                        if (!String.IsNullOrEmpty(t.FormatMask))
                        {
                            writer.Write(", FormatMask = \"");
                            writer.Write(t.FormatMask.Replace("\"", "\\\""));
                            writer.Write("\"");
                        }

                        writer.Write(" };");

                        if (useCompatibleSyntax)
                            writer.Write(" }");

                        writer.WriteLine();
                        writer.WriteLine("    }");
                    },
                    writer);

            writer.WriteLine("    IEnumerable<InputPropertyInfo> IGraphQlInputObject.GetPropertyValues()");
            writer.WriteLine("    {");

            foreach (var fieldName in fieldNameMembers.Keys)
            {
                writer.Write("        if (");
                writer.Write(fieldName);
                writer.Write(".Name != null) yield return ");
                writer.Write(fieldName);
                writer.WriteLine(";");
            }

            writer.WriteLine("    }");
        }

        private string GenerateInterface(string interfaceName, string interfaceDescription, TextWriter writer, Action generateInterfaceBody) =>
            GenerateFileMember("interface", interfaceName, interfaceDescription, null, writer, generateInterfaceBody);

        private string GenerateDataClass(string typeName, string typeDescription, string baseTypeName, TextWriter writer, Action generateClassBody) =>
            GenerateFileMember((_configuration.GeneratePartialClasses ? "partial " : null) + "class", typeName, typeDescription, baseTypeName, writer, generateClassBody);

        private string GenerateFileMember(string memberType, string typeName, string typeDescription, string baseTypeName, TextWriter writer, Action generateFileMemberBody)
        {
            var memberName = typeName + _configuration.ClassPostfix;
            ValidateClassName(memberName);

            GenerateCodeComments(writer, typeDescription, 0);

            writer.Write(GetMemberAccessibility());
            writer.Write(" ");
            writer.Write(memberType);
            writer.Write(" ");
            writer.Write(memberName);

            if (!String.IsNullOrEmpty(baseTypeName))
            {
                writer.Write(" : ");
                writer.Write(baseTypeName);
            }

            writer.WriteLine();
            writer.WriteLine("{");

            generateFileMemberBody();

            writer.Write("}");

            return memberName;
        }

        private static IEnumerable<GraphQlField> GetFragments(GraphQlType type, IDictionary<string, GraphQlType> complexTypeDictionary)
        {
            var fragments = new List<GraphQlField>();
            if (type.Kind != GraphQlTypeKind.Union && type.Kind != GraphQlTypeKind.Interface)
                return fragments;

            foreach (var possibleType in type.PossibleTypes)
                if (complexTypeDictionary.TryGetValue(possibleType.Name, out var consistOfType) && consistOfType.Fields != null)
                    fragments.Add(
                        new GraphQlField
                        {
                            Name = consistOfType.Name,
                            Description = consistOfType.Description,
                            Type =
                                new GraphQlFieldType
                                {
                                    Name = consistOfType.Name,
                                    Kind = consistOfType.Kind
                                }
                        });

            return fragments;
        }

        private List<GraphQlField> GetFieldsToGenerate(GraphQlType type, IDictionary<string, GraphQlType> complexTypeDictionary)
        {
            var typeFields = type.Fields;
            if (type.Kind == GraphQlTypeKind.Union)
            {
                var unionFields = new List<GraphQlField>();
                var unionFieldNames = new HashSet<string>();
                foreach (var possibleType in type.PossibleTypes)
                    if (complexTypeDictionary.TryGetValue(possibleType.Name, out var consistOfType) && consistOfType.Fields != null)
                        unionFields.AddRange(consistOfType.Fields.Where(f => unionFieldNames.Add(f.Name)));

                typeFields = unionFields;
            }

            return typeFields?.Where(FilterDeprecatedFields).ToList();
        }

        private string AddQuestionMarkIfNullableReferencesEnabled(string dataTypeIdentifier) => AddQuestionMarkIfNullableReferencesEnabled(_configuration, dataTypeIdentifier);

        internal static string AddQuestionMarkIfNullableReferencesEnabled(GraphQlGeneratorConfiguration configuration, string dataTypeIdentifier) =>
            configuration.CSharpVersion == CSharpVersion.NewestWithNullableReferences ? dataTypeIdentifier + "?" : dataTypeIdentifier;

        private bool UseCustomClassNameIfDefined(ref string typeName)
        {
            if (!_configuration.CustomClassNameMapping.TryGetValue(typeName, out var customTypeName))
                return false;

            typeName = customTypeName;
            return true;
        }

        private string GetMemberAccessibility() =>
            _configuration.MemberAccessibility == MemberAccessibility.Internal ? "internal" : "public";

        internal bool FilterDeprecatedFields(GraphQlField field) =>
            !field.IsDeprecated || _configuration.IncludeDeprecatedFields;

        private void GenerateDataProperty(
            GraphQlType baseType,
            IGraphQlMember member,
            bool isInterfaceMember,
            bool isDeprecated,
            string deprecationReason,
            bool decorateWithJsonProperty,
            WriteDataClassPropertyBodyDelegate writeBody,
            TextWriter writer)
        {
            var propertyName = NamingHelper.ToPascalCase(member.Name);

            var propertyTypeDescription = GetDataPropertyType(baseType, member);
            var propertyTypeName = propertyTypeDescription.NetTypeName;

            GenerateCodeComments(writer, member.Description, 4);

            if (isDeprecated)
            {
                deprecationReason = String.IsNullOrWhiteSpace(deprecationReason) ? null : $"(@\"{deprecationReason.Replace("\"", "\"\"")}\")";
                writer.WriteLine($"    [Obsolete{deprecationReason}]");
            }

            if (decorateWithJsonProperty)
            {
                decorateWithJsonProperty =
                    _configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.Always ||
                    !String.Equals(
                        member.Name,
                        propertyName,
                        _configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.CaseInsensitive ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);

                if (_configuration.JsonPropertyGeneration == JsonPropertyGenerationOption.Never)
                    decorateWithJsonProperty = false;
            }

            if (!isInterfaceMember && decorateWithJsonProperty)
            {
                writer.WriteLine($"    #if !{PreprocessorDirectiveDisableNewtonsoftJson}");
                writer.WriteLine($"    [JsonProperty(\"{member.Name}\")]");
                writer.WriteLine("    #endif");
            }

            if (baseType.Kind == GraphQlTypeKind.InputObject)
            {
                writer.WriteLine($"    #if !{PreprocessorDirectiveDisableNewtonsoftJson}");
                writer.WriteLine($"    [JsonConverter(typeof(QueryBuilderParameterConverter<{propertyTypeName}>))]");
                writer.WriteLine("    #endif");
                propertyTypeName = AddQuestionMarkIfNullableReferencesEnabled($"QueryBuilderParameter<{propertyTypeName}>");
            }
            
            writer.Write($"    {(isInterfaceMember ? null : "public ")}{propertyTypeName} {propertyName}");

            writeBody(new ScalarFieldTypeDescription { NetTypeName = propertyTypeName, FormatMask = propertyTypeDescription.FormatMask }, GetBackingFieldName(member.Name));

            writer.WriteLine();
        }

        private ScalarFieldTypeDescription GetDataPropertyType(GraphQlType baseType, IGraphQlMember member)
        {
            string propertyType;
            var fieldType = member.Type.UnwrapIfNonNull();

            switch (fieldType.Kind)
            {
                case GraphQlTypeKind.Object:
                case GraphQlTypeKind.Interface:
                case GraphQlTypeKind.Union:
                case GraphQlTypeKind.InputObject:
                    var fieldTypeName = fieldType.Name;
                    if (!UseCustomClassNameIfDefined(ref fieldTypeName))
                        fieldTypeName = NamingHelper.ToPascalCase(fieldTypeName);

                    propertyType = fieldTypeName + _configuration.ClassPostfix;
                    return ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled(propertyType));

                case GraphQlTypeKind.Enum:
                    return _configuration.CustomScalarFieldTypeMapping(baseType, member.Type, member.Name);

                case GraphQlTypeKind.List:
                    var itemTypeName = fieldType.OfType.UnwrapIfNonNull().Name;
                    if (!UseCustomClassNameIfDefined(ref itemTypeName))
                        itemTypeName = NamingHelper.ToPascalCase(itemTypeName);
                    
                    var itemType = IsUnknownObjectScalar(baseType, member.Name, fieldType.OfType) ? "object" : itemTypeName + _configuration.ClassPostfix;
                    var suggestedNetType = ScalarToNetType(baseType, member.Name, fieldType.OfType).NetTypeName.TrimEnd('?');
                    if (!String.Equals(suggestedNetType, "object") && !String.Equals(suggestedNetType, "object?") && !suggestedNetType.TrimEnd().EndsWith("System.Object") && !suggestedNetType.TrimEnd().EndsWith("System.Object?"))
                        itemType = suggestedNetType;

                    propertyType = $"ICollection<{itemType}>";

                    return ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled(propertyType));

                case GraphQlTypeKind.Scalar:
                    return fieldType.Name switch
                    {
                        GraphQlTypeBase.GraphQlTypeScalarInteger => GetIntegerNetType(baseType, member.Type, member.Name),
                        GraphQlTypeBase.GraphQlTypeScalarString => GetCustomScalarType(baseType, member.Type, member.Name),
                        GraphQlTypeBase.GraphQlTypeScalarFloat => GetFloatNetType(baseType, member.Type, member.Name),
                        GraphQlTypeBase.GraphQlTypeScalarBoolean => ConvertToTypeDescription(GetBooleanNetType(baseType, member.Type, member.Name)),
                        GraphQlTypeBase.GraphQlTypeScalarId => GetIdNetType(baseType, member.Type, member.Name),
                        _ => GetCustomScalarType(baseType, member.Type, member.Name)
                    };

                default:
                    return ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled("string"));
            }
        }

        private string GetBooleanNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
            _configuration.BooleanTypeMapping switch
            {
                BooleanTypeMapping.Boolean => "bool?",
                BooleanTypeMapping.Custom => _configuration.CustomScalarFieldTypeMapping(baseType, valueType, valueName).NetTypeName,
                _ => throw new InvalidOperationException($"'{_configuration.BooleanTypeMapping}' not supported")
            };

        private ScalarFieldTypeDescription GetFloatNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
            _configuration.FloatTypeMapping switch
            {
                FloatTypeMapping.Decimal => ConvertToTypeDescription("decimal?"),
                FloatTypeMapping.Float => ConvertToTypeDescription("float?"),
                FloatTypeMapping.Double => ConvertToTypeDescription("double?"),
                FloatTypeMapping.Custom => _configuration.CustomScalarFieldTypeMapping(baseType, valueType, valueName),
                _ => throw new InvalidOperationException($"'{_configuration.FloatTypeMapping}' not supported")
            };

        private ScalarFieldTypeDescription GetIntegerNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
            _configuration.IntegerTypeMapping switch
            {
                IntegerTypeMapping.Int32 => ConvertToTypeDescription("int?"),
                IntegerTypeMapping.Int16 => ConvertToTypeDescription("short?"),
                IntegerTypeMapping.Int64 => ConvertToTypeDescription("long?"),
                IntegerTypeMapping.Custom => _configuration.CustomScalarFieldTypeMapping(baseType, valueType, valueName),
                _ => throw new InvalidOperationException($"'{_configuration.IntegerTypeMapping}' not supported")
            };

        private ScalarFieldTypeDescription GetIdNetType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName) =>
            _configuration.IdTypeMapping switch
            {
                IdTypeMapping.String => ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled("string")),
                IdTypeMapping.Guid => ConvertToTypeDescription("Guid?"),
                IdTypeMapping.Object => ConvertToTypeDescription(AddQuestionMarkIfNullableReferencesEnabled("object")),
                IdTypeMapping.Custom => _configuration.CustomScalarFieldTypeMapping(baseType, valueType, valueName),
                _ => throw new InvalidOperationException($"'{_configuration.IdTypeMapping}' not supported")
            };

        private static void ThrowFieldTypeResolutionFailed(string typeName, string fieldName) =>
            throw new InvalidOperationException($"field type resolution failed - type: {typeName}; field: {fieldName}");

        private void GenerateTypeQueryBuilder(GraphQlType type, IDictionary<string, GraphQlType> complexTypeDictionary, GraphQlSchema schema, TextWriter writer)
        {
            var typeName = type.Name;
            var useCustomName = UseCustomClassNameIfDefined(ref typeName);
            var className = (useCustomName ? typeName : NamingHelper.ToPascalCase(typeName)) + "QueryBuilder" + _configuration.ClassPostfix;
            ValidateClassName(className);

            writer.Write(GetMemberAccessibility());
            writer.Write(" ");

            if (_configuration.GeneratePartialClasses)
                writer.Write("partial ");

            writer.Write("class ");
            writer.Write(className);
            writer.WriteLine($" : GraphQlQueryBuilder<{className}>");
            writer.WriteLine("{");
            writer.Write("    private static readonly FieldMetadata[] AllFieldMetadata =");

            var fields = type.Kind == GraphQlTypeKind.Union ? null : GetFieldsToGenerate(type, complexTypeDictionary);
            if (fields == null)
            {
                writer.WriteLine(" new FieldMetadata[0];");
                writer.WriteLine();
            }
            else
            {
                writer.WriteLine();

                if (_configuration.CSharpVersion == CSharpVersion.Compatible)
                    writer.WriteLine("        new []");

                writer.WriteLine("        {");

                for (var i = 0; i < fields.Count; i++)
                {
                    var comma = i == fields.Count - 1 ? null : ",";
                    var field = fields[i];
                    var fieldType = field.Type.UnwrapIfNonNull();
                    var isList = fieldType.Kind == GraphQlTypeKind.List;
                    var treatUnknownObjectAsComplex = IsUnknownObjectScalar(type, field.Name, fieldType) && !_configuration.TreatUnknownObjectAsScalar;
                    var isComplex = isList || treatUnknownObjectAsComplex || IsComplexType(fieldType.Kind);

                    writer.Write($"            new FieldMetadata {{ Name = \"{field.Name}\"");

                    if (isComplex)
                    {
                        writer.Write(", IsComplex = true");

                        fieldType = isList ? fieldType.OfType.UnwrapIfNonNull() : fieldType;

                        if (fieldType.Kind != GraphQlTypeKind.Scalar && fieldType.Kind != GraphQlTypeKind.Enum)
                        {
                            var fieldTypeName = fieldType.Name;
                            if (fieldTypeName == null)
                                ThrowFieldTypeResolutionFailed(type.Name, field.Name);

                            if (!UseCustomClassNameIfDefined(ref fieldTypeName))
                                fieldTypeName = NamingHelper.ToPascalCase(fieldTypeName);
                            
                            writer.Write($", QueryBuilderType = typeof({fieldTypeName}QueryBuilder{_configuration.ClassPostfix})");
                        }
                    }

                    writer.WriteLine($" }}{comma}");
                }

                writer.WriteLine("        };");
                writer.WriteLine();
            }

            GraphQlDirectiveLocation directiveLocation;
            if (type.Name == schema.QueryType?.Name)
                directiveLocation = GraphQlDirectiveLocation.Query;
            else if (type.Name == schema.MutationType?.Name)
                directiveLocation = GraphQlDirectiveLocation.Mutation;
            else if (type.Name == schema.SubscriptionType?.Name)
                directiveLocation = GraphQlDirectiveLocation.Subscription;
            else
                directiveLocation = GraphQlDirectiveLocation.Field;

            var hasQueryPrefix = directiveLocation != GraphQlDirectiveLocation.Field;
            if (hasQueryPrefix)
                WriteOverrideProperty("string", "Prefix", $"\"{directiveLocation.ToString().ToLowerInvariant()}\"", writer);

            WriteOverrideProperty("string", "TypeName", $"\"{type.Name}\"", writer);

            WriteOverrideProperty("IList<FieldMetadata>", "AllFields", "AllFieldMetadata", writer);

            var stringDataType = AddQuestionMarkIfNullableReferencesEnabled("string");

            writer.Write("    public ");
            writer.Write(className);
            writer.Write("(");
            writer.Write(stringDataType);
            writer.Write(" alias = null");

            var objectDirectiveParameterNameList = WriteDirectiveParameterList(schema, directiveLocation, writer);

            writer.Write(") : base(alias, ");
            writer.Write(objectDirectiveParameterNameList);
            writer.WriteLine(")");

            writer.WriteLine("    {");
            writer.WriteLine("    }");
            writer.WriteLine();

            static string ReturnPrefix(bool requiresFullBody) => requiresFullBody ? "        return " : String.Empty;

            var useCompatibleSyntax = _configuration.CSharpVersion == CSharpVersion.Compatible;
            
            if (hasQueryPrefix)
            {
                writer.Write($"    public {className} WithParameter<T>(GraphQlQueryParameter<T> parameter)");
                WriteQueryBuilderMethodBody(
                    useCompatibleSyntax,
                    writer,
                    () => writer.WriteLine($"{ReturnPrefix(useCompatibleSyntax)}WithParameterInternal(parameter);"));

                writer.WriteLine();
            }

            var fragments = GetFragments(type, complexTypeDictionary);
            fields ??= new List<GraphQlField>();
            var firstFragmentIndex = fields.Count;
            fields.AddRange(fragments);

            for (var i = 0; i < fields.Count; i++)
            {
                var field = fields[i];
                var fieldType = field.Type.UnwrapIfNonNull();
                if (fieldType.Kind == GraphQlTypeKind.List)
                    fieldType = fieldType.OfType;
                
                fieldType = fieldType.UnwrapIfNonNull();
                var isFragment = i >= firstFragmentIndex;

                static bool IsCompatibleArgument(GraphQlFieldType argumentType)
                {
                    argumentType = argumentType.UnwrapIfNonNull();
                    return
                        argumentType.Kind switch
                        {
                            GraphQlTypeKind.Scalar => true,
                            GraphQlTypeKind.Enum => true,
                            GraphQlTypeKind.InputObject => true,
                            GraphQlTypeKind.List => IsCompatibleArgument(argumentType.OfType),
                            _ => false
                        };
                }

                var argumentDefinitions =
                    field.Args?.Where(a => IsCompatibleArgument(a.Type)).Select(a => BuildMethodParameterDefinition(type, a)).ToArray()
                    ?? new QueryBuilderParameterDefinition[0];

                var methodParameters =
                    String.Join(
                        ", ",
                        argumentDefinitions
                            .OrderByDescending(d => d.Argument.Type.Kind == GraphQlTypeKind.NonNull)
                            .Select(d => d.NetParameterDefinitionClause));

                var requiresFullBody = useCompatibleSyntax || argumentDefinitions.Any();
                var returnPrefix = ReturnPrefix(requiresFullBody);

                if (fieldType.Kind == GraphQlTypeKind.Scalar || fieldType.Kind == GraphQlTypeKind.Enum)
                {
                    writer.Write("    public ");
                    writer.Write(className);
                    writer.Write(" With");
                    writer.Write(NamingHelper.ToPascalCase(field.Name));
                    writer.Write("(");
                    writer.Write(methodParameters);

                    if (!String.IsNullOrEmpty(methodParameters))
                        writer.Write(", ");

                    writer.Write(stringDataType);
                    writer.Write(" alias = null");
                    var fieldDirectiveParameterNameList = WriteDirectiveParameterList(schema, GraphQlDirectiveLocation.Field, writer);
                    writer.Write(")");

                    WriteQueryBuilderMethodBody(
                        requiresFullBody,
                        writer,
                        () =>
                        {
                            AppendArgumentDictionary(writer, argumentDefinitions);

                            writer.Write(returnPrefix);
                            writer.Write("WithScalarField(\"");
                            writer.Write(field.Name);
                            writer.Write("\", alias, ");
                            writer.Write(fieldDirectiveParameterNameList);

                            if (argumentDefinitions.Length > 0)
                                writer.Write(", args");

                            writer.WriteLine(");");
                        });
                }
                else
                {
                    var fieldTypeName = fieldType.Name;
                    if (String.IsNullOrEmpty(fieldTypeName))
                        ThrowFieldTypeResolutionFailed(type.Name, field.Name);

                    if (!UseCustomClassNameIfDefined(ref fieldTypeName))
                        fieldTypeName = NamingHelper.ToPascalCase(fieldTypeName);

                    var builderParameterName = NamingHelper.LowerFirst(fieldTypeName);
                    writer.Write($"    public {className} With{NamingHelper.ToPascalCase(field.Name)}{(isFragment ? "Fragment" : null)}({fieldTypeName}QueryBuilder{_configuration.ClassPostfix} {builderParameterName}QueryBuilder");

                    if (argumentDefinitions.Length > 0)
                    {
                        writer.Write(", ");
                        writer.Write(methodParameters);
                    }

                    writer.Write(")");

                    WriteQueryBuilderMethodBody(
                        requiresFullBody,
                        writer,
                        () =>
                        {
                            AppendArgumentDictionary(writer, argumentDefinitions);

                            writer.Write(returnPrefix);
                            writer.Write("With");

                            if (isFragment)
                                writer.Write("Fragment(");
                            else
                            {
                                writer.Write("ObjectField(\"");
                                writer.Write(field.Name);
                                writer.Write("\", ");
                            }

                            writer.Write(builderParameterName);
                            writer.Write("QueryBuilder");

                            if (argumentDefinitions.Length > 0)
                                writer.Write(", args");

                            writer.WriteLine(");");
                        });
                }

                if (!isFragment)
                {
                    writer.WriteLine();

                    writer.Write($"    public {className} Except{NamingHelper.ToPascalCase(field.Name)}()");

                    WriteQueryBuilderMethodBody(
                        requiresFullBody,
                        writer,
                        () => writer.WriteLine($"{returnPrefix}ExceptField(\"{field.Name}\");"));
                }

                if (i < fields.Count - 1)
                    writer.WriteLine();
            }

            writer.WriteLine("}");
        }

        private string WriteDirectiveParameterList(GraphQlSchema schema, GraphQlDirectiveLocation directiveLocation, TextWriter writer)
        {
            var directiveParameterNames = new List<string>();

            foreach (var directive in schema.Directives.Where(d => d.Locations.Contains(directiveLocation)))
            {
                var csharpDirectiveName = NamingHelper.ToPascalCase(directive.Name);
                var directiveClassName = csharpDirectiveName + "Directive";
                var parameterName = NamingHelper.LowerFirst(csharpDirectiveName);
                directiveParameterNames.Add(parameterName);

                writer.Write(", ");
                writer.Write(AddQuestionMarkIfNullableReferencesEnabled(directiveClassName));
                writer.Write(" ");
                writer.Write(parameterName);
                writer.Write(" = null");
            }

            return
                directiveParameterNames.Any()
                    ? "new " + AddQuestionMarkIfNullableReferencesEnabled("GraphQlDirective") + "[] { " + String.Join(", ", directiveParameterNames) + " }"
                    : "null";
        }

        private static void WriteQueryBuilderMethodBody(bool requiresFullBody, TextWriter writer, Action writeBody)
        {
            if (requiresFullBody)
            {
                writer.WriteLine();
                writer.WriteLine("    {");
            }
            else
                writer.Write(" => ");

            writeBody();

            if (requiresFullBody)
                writer.WriteLine("    }");
        }

        private void WriteOverrideProperty(string propertyType, string propertyName, string propertyValue, TextWriter writer)
        {
            writer.Write("    protected override ");
            writer.Write(propertyType);
            writer.Write(" ");
            writer.Write(propertyName);
            writer.Write(" { get");

            if (_configuration.CSharpVersion == CSharpVersion.Compatible)
            {
                writer.Write(" { return ");
                writer.Write(propertyValue);
                writer.WriteLine("; } } ");
            }
            else
            {
                writer.Write("; } = ");
                writer.Write(propertyValue);
                writer.WriteLine(";");
            }

            writer.WriteLine();
        }

        private QueryBuilderParameterDefinition BuildMethodParameterDefinition(GraphQlType baseType, GraphQlArgument argument)
        {
            var argumentType = argument.Type;
            var isArgumentNotNull = argumentType.Kind == GraphQlTypeKind.NonNull;
            var isTypeNotNull = isArgumentNotNull;
            var unwrappedType = argumentType.UnwrapIfNonNull();
            var isCollection = unwrappedType.Kind == GraphQlTypeKind.List;
            if (isCollection)
            {
                isTypeNotNull = unwrappedType.OfType.Kind == GraphQlTypeKind.NonNull;
                argumentType = unwrappedType.OfType;
                unwrappedType = argumentType.UnwrapIfNonNull();
            }

            var argumentTypeDescription = unwrappedType.Kind == GraphQlTypeKind.Enum ? ConvertToTypeDescription(NamingHelper.ToPascalCase(unwrappedType.Name) + "?") : ScalarToNetType(baseType, argument.Name, argumentType);
            var argumentNetType = argumentTypeDescription.NetTypeName;
            if (isTypeNotNull)
                argumentNetType = argumentNetType.TrimEnd('?');

            var isInputObject = unwrappedType.Kind == GraphQlTypeKind.InputObject;
            if (isInputObject)
            {
                argumentNetType = unwrappedType.Name;

                if (!UseCustomClassNameIfDefined(ref argumentNetType))
                    argumentNetType = NamingHelper.ToPascalCase(argumentNetType);

                argumentNetType += _configuration.ClassPostfix;
            }

            argumentNetType = isCollection ? $"QueryBuilderParameter<IEnumerable<{argumentNetType}>>" : $"QueryBuilderParameter<{argumentNetType}>";

            if (!isArgumentNotNull)
                argumentNetType = AddQuestionMarkIfNullableReferencesEnabled(argumentNetType);

            var netParameterName = NamingHelper.ToValidCSharpName(NamingHelper.LowerFirst(NamingHelper.ToPascalCase(argument.Name)));
            var argumentDefinition = $"{argumentNetType} {netParameterName}";
            if (!isArgumentNotNull)
                argumentDefinition += " = null";

            return
                new QueryBuilderParameterDefinition
                {
                    Argument = argument,
                    NetParameterName = netParameterName,
                    NetParameterDefinitionClause = argumentDefinition,
                    FormatMask = argumentTypeDescription.FormatMask
                };
        }

        private static void ValidateClassName(string className)
        {
            if (!CSharpHelper.IsValidIdentifier(className))
                throw new InvalidOperationException($"Resulting class name '{className}' is not valid. ");
        }

        private static void AppendArgumentDictionary(TextWriter writer, ICollection<QueryBuilderParameterDefinition> argumentDefinitions)
        {
            if (argumentDefinitions.Count == 0)
                return;

            writer.WriteLine("        var args = new List<QueryBuilderArgumentInfo>();");

            static void WriteAddKeyValuePair(TextWriter writer, QueryBuilderParameterDefinition argumentDefinition)
            {
                var argument = argumentDefinition.Argument;
                writer.Write("args.Add(new QueryBuilderArgumentInfo { ArgumentName = \"");
                writer.Write(argument.Name);
                writer.Write("\", ArgumentValue = ");
                writer.Write(argumentDefinition.NetParameterName);

                if (!String.IsNullOrEmpty(argumentDefinition.FormatMask))
                {
                    writer.Write(", FormatMask = \"");
                    writer.Write(argumentDefinition.FormatMask.Replace("\"", "\\\""));
                    writer.Write("\"");
                }

                writer.WriteLine("} );");
            }

            foreach (var argumentDefinition in argumentDefinitions)
            {
                if (argumentDefinition.Argument.Type.Kind == GraphQlTypeKind.NonNull)
                {
                    writer.Write("        ");
                    WriteAddKeyValuePair(writer, argumentDefinition);
                }
                else
                {
                    writer.WriteLine($"        if ({NamingHelper.ToValidCSharpName(argumentDefinition.Argument.Name)} != null)");
                    writer.Write("            ");
                    WriteAddKeyValuePair(writer, argumentDefinition);
                    writer.WriteLine();
                }
            }
        }

        private void GenerateEnums(GraphQlSchema schema, TextWriter writer)
        {
            foreach (var type in schema.Types.Where(t => t.Kind == GraphQlTypeKind.Enum && !t.Name.StartsWith("__")))
            {
                GenerateEnum(type, writer);
                writer.WriteLine();
            }
        }

        private void GenerateEnum(GraphQlType type, TextWriter writer)
        {
            GenerateCodeComments(writer, type.Description, 0);
            writer.Write("public enum ");
            writer.WriteLine(NamingHelper.ToPascalCase(type.Name));
            writer.WriteLine("{");

            var enumValues = type.EnumValues.ToList();
            for (var i = 0; i < enumValues.Count; i++)
            {
                var enumValue = enumValues[i];
                GenerateCodeComments(writer, enumValue.Description, 4);
                writer.Write("    ");
                var netIdentifier = NamingHelper.ToCSharpEnumName(enumValue.Name);
                if (netIdentifier != enumValue.Name)
                    writer.Write($"[EnumMember(Value=\"{enumValue.Name}\")] ");

                writer.Write(netIdentifier);

                if (i < enumValues.Count - 1)
                    writer.Write(",");

                writer.WriteLine();
            }

            writer.WriteLine("}");
        }

        private static readonly HashSet<GraphQlDirectiveLocation> SupportedDirectiveLocations =
            new HashSet<GraphQlDirectiveLocation>
            {
                GraphQlDirectiveLocation.Object,
                GraphQlDirectiveLocation.Field,
                GraphQlDirectiveLocation.Query,
                GraphQlDirectiveLocation.Mutation,
                GraphQlDirectiveLocation.Subscription
            };

        private void GenerateDirectives(GraphQlSchema schema, TextWriter writer)
        {
            foreach (var directive in schema.Directives.Where(t => SupportedDirectiveLocations.Overlaps(t.Locations)))
            {
                GenerateDirective(directive, writer);
                writer.WriteLine();
            }
        }

        private void GenerateDirective(GraphQlDirective directive, TextWriter writer)
        {
            GenerateCodeComments(writer, directive.Description, 0);

            var directiveName = NamingHelper.ToPascalCase(directive.Name);

            var orderedArgumentDefinitions = directive.Args.OrderByDescending(a => a.Type.Kind == GraphQlTypeKind.NonNull).Select(a => BuildMethodParameterDefinition(null, a)).ToArray();
            var argumentList = String.Join(", ", orderedArgumentDefinitions.Select(d => d.NetParameterDefinitionClause));

            writer.Write("public class ");
            writer.Write(directiveName);
            writer.Write("Directive");
            writer.WriteLine(" : GraphQlDirective");
            writer.WriteLine("{");
            writer.Write("    public ");
            writer.Write(directiveName);
            writer.Write("Directive(");
            writer.Write(argumentList);
            writer.Write(") : base(\"");
            writer.Write(directive.Name);
            writer.WriteLine("\")");
            writer.WriteLine("    {");

            foreach (var definition in orderedArgumentDefinitions)
            {
                writer.Write("        AddArgument(\"");
                writer.Write(definition.Argument.Name);
                writer.Write("\", ");
                writer.Write(NamingHelper.ToValidCSharpName(definition.Argument.Name));
                writer.WriteLine(");");
            }

            writer.WriteLine("    }");
            writer.WriteLine("}");
        }

        private void GenerateCodeComments(TextWriter writer, string description, int offset)
        {
            if (String.IsNullOrWhiteSpace(description))
                return;

            var offsetSpaces = new String(' ', offset);

            if (_configuration.CommentGeneration.HasFlag(CommentGenerationOption.CodeSummary))
            {
                writer.Write(offsetSpaces);
                writer.WriteLine("/// <summary>");
                writer.Write(offsetSpaces);
                writer.WriteLine("/// " + String.Join(Environment.NewLine + offsetSpaces + "/// ", description.Split('\n').Select(l => l.Trim())));
                writer.Write(offsetSpaces);
                writer.WriteLine("/// </summary>");
            }

            if (_configuration.CommentGeneration.HasFlag(CommentGenerationOption.DescriptionAttribute))
            {
                writer.Write(offsetSpaces);
                writer.WriteLine($"[Description(@\"{description.Replace("\"", "\"\"")}\")]");
            }
        }

        private bool IsUnknownObjectScalar(GraphQlType baseType, string valueName, GraphQlFieldType fieldType)
        {
            if (fieldType.UnwrapIfNonNull().Kind != GraphQlTypeKind.Scalar)
                return false;

            var netType = ScalarToNetType(baseType, valueName, fieldType).NetTypeName;
            return netType == "object" || netType.TrimEnd().EndsWith("System.Object") || netType == "object?" || netType.TrimEnd().EndsWith("System.Object?");
        }

        private ScalarFieldTypeDescription ScalarToNetType(GraphQlType baseType, string valueName, GraphQlFieldType valueType) =>
            valueType.UnwrapIfNonNull().Name switch
            {
                GraphQlTypeBase.GraphQlTypeScalarInteger => GetIntegerNetType(baseType, valueType, valueName),
                GraphQlTypeBase.GraphQlTypeScalarString => GetCustomScalarType(baseType, valueType, valueName),
                GraphQlTypeBase.GraphQlTypeScalarFloat => GetFloatNetType(baseType, valueType, valueName),
                GraphQlTypeBase.GraphQlTypeScalarBoolean => ConvertToTypeDescription(GetBooleanNetType(baseType, valueType, valueName)),
                GraphQlTypeBase.GraphQlTypeScalarId => GetIdNetType(baseType, valueType, valueName),
                _ => GetCustomScalarType(baseType, valueType, valueName)
            };

        private ScalarFieldTypeDescription GetCustomScalarType(GraphQlType baseType, GraphQlTypeBase valueType, string valueName)
        {
            if (_configuration.CustomScalarFieldTypeMapping == null)
                throw new InvalidOperationException($"'{nameof(_configuration.CustomScalarFieldTypeMapping)}' missing");

            var typeDescription = _configuration.CustomScalarFieldTypeMapping(baseType, valueType, valueName);
            if (String.IsNullOrWhiteSpace(typeDescription.NetTypeName))
                throw new InvalidOperationException($".NET type for '{baseType.Name}.{valueName}' ({valueType.Name}) cannot be resolved. Please check {nameof(_configuration)}.{nameof(_configuration.CustomScalarFieldTypeMapping)} implementation. ");

            if (typeDescription.FormatMask != null && String.IsNullOrWhiteSpace(typeDescription.FormatMask))
                throw new InvalidOperationException("invalid format mask");

            return typeDescription;
        }

        private static ScalarFieldTypeDescription ConvertToTypeDescription(string netTypeName) => new ScalarFieldTypeDescription { NetTypeName = netTypeName };

        private struct QueryBuilderParameterDefinition
        {
            public GraphQlArgument Argument;
            public string NetParameterName;
            public string NetParameterDefinitionClause;
            public string FormatMask;
        }
    }
}